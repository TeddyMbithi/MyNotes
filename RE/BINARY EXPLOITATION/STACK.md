### What is the Stack?

The **call stack** (or just "stack") is a special region of a program's memory used for managing function calls and local (temporary) data. It's like a stack of plates: you **push** new items on top when entering a function, and **pop** them off when exiting. This ensures everything happens in the correct order (last in, first out – LIFO).

The stack handles:

- Local variables (e.g., buffers, ints in a function)
- Function parameters (in older calling conventions)
- Saved registers
- Return address (where to go back after the function finishes)

It's fast because it's managed automatically by the CPU instructions (like push, pop, call, ret on x86).

### Why the Stack Grows Downwards

In most architectures (including x86/x86_64 on Linux/Kali), the stack starts at **high memory addresses** and grows **towards lower addresses** (downwards).

Reason:

- The program's code, data, and heap (dynamic memory from malloc) start at **low addresses** and grow **upwards**.
- This leaves a big empty space in the middle for both to expand freely without fixed limits.

![linux - Do memory mapping segment and heap grow until they meet ...](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQyW3rDhDVTKj5Q3OhXGyxeUBxtKqQcFmtb9R6xLXXimcaxpWJx&s)


![In-Memory Layout of a Program (Process) « Gabriele Tolomei](https://gabrieletolomei.wordpress.com/wp-content/uploads/2013/10/memory_layout.jpg)

![memory management - Stack and Heap locations in RAM - Stack Overflow](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRH1WTpnOKriohmPu8bbDv6dOdoKMmOprfcm2Wv2KSTahRkPKQ&s)

[stackoverflow.com](https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram)

![How Does Linux Memory Work?. Similar to CPU management, memory ...](https://miro.medium.com/v2/resize:fit:1400/1*CHCagIJgUkFZyL49a9td-g.png)



Typical Linux process virtual memory layout: Code/data at bottom (growing ↑), stack at top (growing ↓), heap in between.

### Key Registers Involved (x86 32-bit Example)

- **EIP** (Instruction Pointer): Points to the next instruction to execute.
- **ESP** (Stack Pointer): Points to the **top** of the stack (lowest address currently in use). Moves down on push/call.
- **EBP** (Base/Frame Pointer): Points to the **base** (higher address) of the current function's frame. Used for easy access to locals.

![x86 Assembly and Call Stack | Computer Security](https://textbook.cs161.org/assets/images/memory-safety/x86/stack7.png)

[textbook.cs161.org](https://textbook.cs161.org/memory-safety/x86.html)

![Stack Frames & Pointers | Cameron Wickes](https://www.cameronwickes.co.uk/_nuxt/uploads/9072fc7-640.jpg)

[cameronwickes.co.uk](https://www.cameronwickes.co.uk/stack-frames-pointers/)

### Detailed Stack Frame Layout (One Function's Space)

When a function is called (function prologue):

1. call instruction pushes the return address and jumps.
2. push ebp saves old EBP.
3. mov ebp, esp sets new frame.
4. sub esp, N allocates space for locals (moves ESP down).

Layout from **high address** to **low address**:

![The details of C function stack (and heap) operation when function ...](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image005.png)

[tenouk.com](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html)

![Understanding the Stack — A Precursor to exploiting Buffer ...](https://miro.medium.com/0*0_ldrMQW__kRL7HV.jpg)

[blog.devgenius.io](https://blog.devgenius.io/understanding-the-stack-a-precursor-to-exploiting-buffer-overflow-8c6972fdb4ac)

![Stack Frames & Pointers | Cameron Wickes](https://www.cameronwickes.co.uk/_nuxt/uploads/9072fc7-640.jpg)

[cameronwickes.co.uk](https://www.cameronwickes.co.uk/stack-frames-pointers/)

![The details of C function stack (and heap) operation when function ...](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2_files/image011.png)

[tenouk.com](https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html)

![Lab 3: Assembly and Buffer Overflow - HackMD](https://cs.brown.edu/courses/csci1310/2020/assign/labs/assets/lab3-stack6.png)

[cs.brown.edu](https://cs.brown.edu/courses/csci1310/2020/assign/labs/lab3.html)

![Understanding the Stack — A Precursor to exploiting Buffer ...](https://miro.medium.com/v2/resize:fit:1350/0*K992sQOanLQaLOat.jpg)

[blog.devgenius.io](https://blog.devgenius.io/understanding-the-stack-a-precursor-to-exploiting-buffer-overflow-8c6972fdb4ac)

- **Arguments** (pushed by caller, higher than EBP)
- **Saved EIP** (return address – critical for control flow)
- **Saved EBP** (old frame pointer)
- **Local variables/buffers** (allocated by sub esp)
- ESP points here ↓ (grows down)

### Why This Matters for Exploits: Buffer Overflow

Vulnerable code like strcpy(buffer, input) doesn't check size. If you send too much input:

- It fills the buffer.
- Overflows into saved EBP.
- Then overwrites **saved EIP** (return address).

When function returns (ret): Pops EIP → program jumps to your controlled address → code execution!

![If the stack grows downwards, how can a buffer overflow overwrite ...](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTjqDfS9DMaYATcVJ0CmgO2GuDD0X2IQ3Sv36264Z1Rvi70ZsM&s)

[security.stackexchange.com](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)

![Call Stack - buffer overflow vulnerability | ZeroBone](https://zerobone.net/assets/img/blog/call-stack-buffer-overflow-tmb@0,5x.jpg)

[zerobone.net](https://zerobone.net/blog/cs/call-stack-buffer-overflow/)

![Windows Exploit Development With Buffer Overflow Example 1 | by ...](https://miro.medium.com/1*srairTVcbwgy9pvT9zq7rg.jpeg)

[whichbuffer.medium.com](https://whichbuffer.medium.com/windows-exploit-development-with-buffer-overflow-example-1-158ddcc029fe)

![28 Security — An Introduction to Computer Networks, unicode-safer ...](https://intronetworks.cs.luc.edu/current/uhtml/_images/basic_stack_overflow.svg)

[intronetworks.cs.luc.edu](https://intronetworks.cs.luc.edu/current/uhtml/security.html)

Classic stack smashing: Overflow travels "up" the frame (towards higher addresses) to hit the return address.

This is the foundation of basic binary exploitation (what you're learning now). Modern protections (ASLR, NX, Stack Canaries) make it harder, but understanding the raw stack is key to everything else (ROP, heap exploits, etc.).